# 25. Reverse Nodes in k-Group

### Description

Given a linked list, reverse the nodes of a linked list _k_ at a time and return its modified list.

_k_ is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of _k_ then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

### **Examples**

**Example 1:**![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```text
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]
```

**Example 2:**![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```text
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]
```

**Example 3:**

```text
Input: head = [1,2,3,4,5], k = 1
Output: [1,2,3,4,5]
```

**Example 4:**

```text
Input: head = [1], k = 1
Output: [1]
```

### **Constraints:**

* The number of nodes in the list is in the range `sz`.
* `1 <= sz <= 5000`
* `0 <= Node.val <= 1000`
* `1 <= k <= sz`

###  **Follow-up**

Can you solve the problem in O\(1\) extra memory space?

### Solutions

{% tabs %}
{% tab title="Java - Iterative" %}
```java
public ListNode reverseKGroup(ListNode head, int k) { 
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;
    
    while (head != null) {
        ListNode first = prev.next;
        ListNode last = first;
        
        for (int i = 0; i < k - 1; i++) {
            if (last == null) return dummy.next;
            last = last.next;
        }
        if (last == null) return dummy.next;
        
        ListNode tail = last.next;
        ListNode cur = first;
        while (cur != tail) {
            ListNode next = cur.next;
            cur.next = prev.next;
            prev.next = cur;
            cur = next;
        }
        
        first.next = tail;
        prev = first;
        head = prev.next;
    }
    return dummy.next;
}
```
{% endtab %}

{% tab title="Java - Recursive" %}
```java
public ListNode reverseKGroupI(ListNode head, int k) {
    if (head == null) return null;
    ListNode h = head, p = head;
    int count = 1;
    while (h.next != null && count < k) {
        h = h.next;
        count++;
    }
    if (count == k) {
        ListNode post = reverseKGroupI(h.next, k);
        h.next = null;
        ListNode[] result = reverse(p);
        result[0].next = post;
        head = result[1];
    }
    return head;
}

private ListNode[] reverse(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode tmp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = tmp;
    }
    return new ListNode[]{head, pre};
}
```
{% endtab %}
{% endtabs %}

