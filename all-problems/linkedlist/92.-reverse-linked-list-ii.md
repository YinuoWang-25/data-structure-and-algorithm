# 92. Reverse Linked List II

### Description

Reverse a linked list from position _m_ to _n_. Do it in one-pass.

**Note:** 1 ≤ _m_ ≤ _n_ ≤ length of list.

### **Example**

```text
Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL
```

### Intuition

#### Four pointers

**prev**: needed as left bound

**tail**: no need in this case

**last**: need to get it from beginning. `last = prev.next`

**dummy**: need it to be returned later

#### Three steps

1. Reach **prev** node

   we need to take **m - 1** steps from dummy node

2. Reverse nodes in iterative or recursive way

   We traverse every node need to reverse and insert it between **prev** and prev.next

3. Connect **last** with **tail** : `last.next = tail`

#### How many nodes to be traversed

We need to reverse `n - m + 1` nodes

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;
    
    for (int i = 0; i < m - 1; i++) {
        prev = prev.next;
    }
    ListNode last = prev.next;
    ListNode cur = prev.next;
    while (cur != null && n >= m) {
        ListNode next = cur.next;
        cur.next = prev.next;
        prev.next = cur;
        cur = next;
        n--;
    }
    last.next = cur;
    return dummy.next;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func reverseBetween(head *ListNode, m int, n int) *ListNode {
    dummy := &ListNode{Val: 0, Next: head}
	prev := dummy
	for i := 0 ; i < m - 1; i++ {
		prev = prev.Next
	}
	last := prev.Next
	cur := prev.Next
	for i := 0 ; i <= n - m ; i++ {
		next := cur.Next
		cur.Next = prev.Next
		prev.Next = cur
		cur = next
	}
	last.Next = cur
	return dummy.Next
}
```
{% endtab %}
{% endtabs %}

