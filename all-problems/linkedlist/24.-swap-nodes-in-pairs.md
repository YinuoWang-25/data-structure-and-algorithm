# 24. Swap Nodes in Pairs

### Description

Given a linked list, swap every two adjacent nodes and return its head.

You may **not** modify the values in the list's nodes. Only nodes itself may be changed.

### Examples

**Example 1:**

![https://assets.leetcode.com/uploads/2020/10/03/swap\_ex1.jpg](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```text
Input: head = [1,2,3,4]
Output: [2,1,4,3]

```

**Example 2:**

```text
Input: head = []
Output: []

```

**Example 3:**

```text
Input: head = [1]
Output: [1]

```

### **Constraints**

* The number of nodes in the list is in the range `[0, 100]`.
* `0 <= Node.val <= 100`

### Intuition

#### Five pointers

**prev**: needed as left bound

**tail**: head for next group

**last**: no need in this case. `last == cur`

**cur**: is `head` here

**dummy**: need it to be returned later

#### Four steps

1. Reach **prev** node

   `prev` originally is `dummy`, then it should be `last` node of last group

2. Reverse nodes in iterative or recursive way

   We insert second between **prev** and **prev.next**

3. Connect **last** with **tail** : `cur.next = tail`
4. Update pointers: especially **prev** and **cur**

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;
    
    while (head != null && head.next != null) {
				// get tail node
        ListNode tail = head.next.next;
				// insert the second node between prev and prev.next
        prev.next = head.next;
        head.next.next = head;
				// Connect **last** with **tail**
        head.next = tail;
				// update pointers
        prev = head;
        head = tail;
    }
    return dummy.next;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func swapPairs(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
	dummy := &ListNode{Val: 0}
	dummy.Next = head
	prev := dummy
	for prev.Next != nil && prev.Next.Next != nil {
        first, second := prev.Next, prev.Next.Next
        first.Next = second.Next
        second.Next = first
        prev.Next = second
        prev = first
	}
	return dummy.Next
}
```
{% endtab %}
{% endtabs %}

