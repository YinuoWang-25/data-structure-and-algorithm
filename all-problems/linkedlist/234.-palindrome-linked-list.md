# 234. Palindrome Linked List

### Description

Given a singly linked list, determine if it is a palindrome.

### Examples

**Example 1:**

```text
Input: 1->2
Output: false
```

**Example 2:**

```text
Input: 1->2->2->1
Output: true
```

### **Follow up**

Could you do it in O\(n\) time and O\(1\) space?

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    ListNode middle = findMiddle(head);
    ListNode right = middle.next;
    middle.next = null;
    ListNode newRight = reverse(right);
    while (head != null && newRight != null) {
        if (head.val != newRight.val) {
            return false;
        }
        head = head.next;
        newRight = newRight.next;
    }
    return true;
}

private ListNode reverse(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

private ListNode findMiddle(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func isPalindrome(head *ListNode) bool {
	if head == nil {
		return true
	}
	first := head
	middle := findMiddle(head)
	second := middle.Next
	middle.Next = nil
    second = reverse(second)
	for first != nil && second != nil {
		if first.Val != second.Val {
			return false
		}
		first = first.Next
		second = second.Next
	}
    if first != nil {
        first = first.Next
    }
	return first == nil && second == nil
}

func findMiddle(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
  slow, fast := head, head

	for fast.Next != nil && fast.Next.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	return slow
}

func reverse(head *ListNode) *ListNode {
	var prev *ListNode
	cur := head
	for cur != nil {
		next := cur.Next
		cur.Next = prev
		prev = cur
		cur = next
	}
	return prev
}
```
{% endtab %}
{% endtabs %}

