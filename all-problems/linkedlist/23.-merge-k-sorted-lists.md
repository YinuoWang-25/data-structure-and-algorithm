# 23. Merge k Sorted Lists

### Description

You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

### Examples

**Example 1:**

```text
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

```

**Example 2:**

```text
Input: lists = []
Output: []

```

**Example 3:**

```text
Input: lists = [[]]
Output: []

```

### **Constraints**

* `k == lists.length`
* `0 <= k <= 10^4`
* `0 <= lists[i].length <= 500`
* `10^4 <= lists[i][j] <= 10^4`
* `lists[i]` is sorted in **ascending order**.
* The sum of `lists[i].length` won't exceed `10^4`.

### Intuition

* Three solutions

K 路归并

### Solutions

{% tabs %}
{% tab title="GoLang" %}
```go
func mergeKLists(lists []*ListNode) *ListNode {
	pq := make(priorityqueue.PriorityQueue, 0)

	for _, node := range lists {
		if node != nil {
			pq = append(pq, (*priorityqueue.ListNode)(node))
		}
	}

	if len(pq) == 0 {
		return nil
	}

	heap.Init(&pq)

	head := &ListNode{}
	dummyHead := head

	for len(pq) > 0 {
		min := heap.Pop(&pq)
		minNode := min.(*ListNode)
		head.Next = (*base.ListNode)(minNode)
		head = (*ListNode)(head.Next)

		if minNode.Next != nil {
			heap.Push(&pq, minNode.Next)
		}
	}
	return (*ListNode)(dummyHead.Next)
}
```
{% endtab %}

{% tab title="Java" %}
```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    
    PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (a, b) -> a.val - b.val);
    for (ListNode list : lists) {
        if (list != null) {
            pq.offer(list);
        }
    }
    
    ListNode dummy = new ListNode(0);
    ListNode prev = dummy;
    
    while (!pq.isEmpty()) {
        ListNode cur = pq.poll();
        prev.next = cur;
        prev = prev.next;
        
        if (cur.next != null) {
            pq.offer(cur.next);
        }
    }
    
    prev.next = null;
    return dummy.next;
}
```
{% endtab %}
{% endtabs %}

