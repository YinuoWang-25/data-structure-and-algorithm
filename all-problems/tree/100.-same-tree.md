# 100. Same Tree

### Description

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

### Examples

**Example 1:**

![https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```text
Input: p = [1,2,3], q = [1,2,3]
Output: true

```

**Example 2:**

![https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```text
Input: p = [1,2], q = [1,null,2]
Output: false

```

**Example 3:**

![https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

```text
Input: p = [1,2,1], q = [1,1,2]
Output: false

```

### **Constraints**

* The number of nodes in both trees is in the range `[0, 100]`.
* `-10^4 <= Node.val <= 10^4`

### Solutions

{% tabs %}
{% tab title="Java - Recursive" %}
```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    
    if (p == null || q == null || p.val != q.val) {
        return false;
    }
    
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```
{% endtab %}

{% tab title="Java - iterative" %}
```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null || p.val != q.val) return false;
    
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(p);
    queue.offer(q);
    
    while (!queue.isEmpty()) {
        TreeNode first = queue.poll();
        TreeNode second = queue.poll();
        
        if (first == null && second == null) {
            continue;
        } else if (first == null || second == null || first.val != second.val) {
            return false;
        } else {
            queue.offer(first.left);
            queue.offer(second.left);
            queue.offer(second.right);
            queue.offer(first.right);
        }
    }
    
    return true;
}
```
{% endtab %}

{% tab title="GoLang - Recursive" %}
```go
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil {
        return true
    }
    if p == nil || q == nil || p.Val != q.Val {
        return false
    }
    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}
```
{% endtab %}

{% tab title="GoLang - Iterative" %}
```go
func isSameTree(p *TreeNode, q *TreeNode) bool {
    var queue []*TreeNode
    queue = append(queue, p)
    queue = append(queue, q)
    for len(queue) > 0 {
        first := queue[0]
        second := queue[1]
        queue = queue[2:]
        if first == nil && second == nil {
            continue
        } else if first == nil || second == nil || first.Val != second.Val{
            return false
        } else {
            queue = append(queue, first.Left)
            queue = append(queue, second.Left)
            queue = append(queue, first.Right)
            queue = append(queue, second.Right)
        }
    }
    return true
}
```
{% endtab %}
{% endtabs %}

