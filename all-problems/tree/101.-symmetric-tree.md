# 101. Symmetric Tree

### Description

Given a binary tree, check whether it is a mirror of itself \(ie, symmetric around its center\).

For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:

```text
    1
   / \\
  2   2
 / \\ / \\
3  4 4  3

```

But the following `[1,2,2,null,3,null,3]` is not:

```text
    1
   / \\
  2   2
   \\   \\
   3    3

```

### **Follow up**

Solve it both recursively and iteratively.

### Solutions

{% tabs %}
{% tab title="Java - Recursive" %}
```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode p, TreeNode q) {
    if (p == null && q == null) return true;
    if (p == null || q == null || p.val != q.val) return false;
    return isSymmetric(p.left, q.right) && isSymmetric(p.right, q.left);
    
}
```
{% endtab %}

{% tab title="Java - Iterative" %}
```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    
    TreeNode p = root.left;
    TreeNode q = root.right;
    
    if (p == null && q == null) return true;
    if (p == null || q == null || p.val != q.val) return false;
    
    Deque<TreeNode> queue = new LinkedList<>();
    queue.offer(p);
    queue.offer(q);
    
    while (!queue.isEmpty()) {
        TreeNode first = queue.poll();
        TreeNode second = queue.poll();
        
        if (first == null && second == null) {
            continue;
        } else if (first == null || second == null || first.val != second.val) {
            return false;
        } else {
            queue.offer(first.left);
            queue.offer(second.right);
            queue.offer(second.left);
            queue.offer(first.right);
        }
        
    }
    return true; 
}
```
{% endtab %}

{% tab title="GoLang - Recursive" %}
```go
func isSymmetric(root *TreeNode) bool {
  if root == nil {
    return true
  }
	return checkSymmetric(root.Left, root.Right)
}

func checkSymmetric(p *TreeNode, q *TreeNode) bool {
	if p == nil && q == nil {
		return true
	}
	if p == nil || q == nil || p.Val != q.Val {
		return false
	}
	return checkSymmetric(p.Left, q.Right) && checkSymmetric(p.Right, q.Left)
}
```
{% endtab %}

{% tab title="GoLang - Iterative" %}
```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
		return true
	}
	var queue []*TreeNode
	queue = append(queue, root.Left)
	queue = append(queue, root.Right)
	for len(queue) > 0 {
		first := queue[0]
		second := queue[1]
		queue = queue[2:]
		if first == nil && second == nil {
			continue
		} else if first == nil || second == nil || first.Val != second.Val {
			return false
		} else {
			queue = append(queue, first.Left)
			queue = append(queue, second.Right)
			queue = append(queue, second.Left)
			queue = append(queue, first.Right)
		}
	}
	return true
}
```
{% endtab %}
{% endtabs %}

