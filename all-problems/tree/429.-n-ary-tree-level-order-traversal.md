# 429. N-ary Tree Level Order Traversal

### Description

Given an n-ary tree, return the level order traversal of its nodes' values.

_Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value \(See examples\)._

### Examples

**Example 1:**

![https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

```text
Input: root = [1,null,3,2,4,null,5,6]
Output: [[1],[3,2,4],[5,6]]

```

**Example 2:**

![https://assets.leetcode.com/uploads/2019/11/08/sample\_4\_964.png](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

```text
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]

```

### **Constraints**

* The height of the n-ary tree is less than or equal to `1000`
* The total number of nodes is between `[0, 10^4]`

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
public List<List<Integer>> levelOrder(Node root) {
    LinkedList<List<Integer>> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    
    Queue<Node> q = new LinkedList<>();
    q.add(root);
    
    while (q.size() > 0) {
        int sz = q.size();
        LinkedList<Integer> curLevel = new LinkedList<Integer>();
        
        while (sz > 0) {
            Node curNode = q.poll();
            curLevel.add(curNode.val);
            for (Node child : curNode.children) {
                q.offer(child);
            }
            sz--;
        }
        
        res.add(curLevel);
    }
    
    return res;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func levelOrder(root *Node) [][]int {
  var res [][]int
	if root == nil {
		return res
	}

	var queue []*Node

	queue = append(queue, root)

	for len(queue) != 0 {
		var cur []int
		size := len(queue)
		for i := 0; i < size; i++ {
			curTreeNode := queue[0]
			queue = queue[1:]
			cur = append(cur, curTreeNode.Val)

			if curTreeNode.Children != nil {
				for i := 0; i < len(curTreeNode.Children); i++ {
					child := curTreeNode.Children[i]
					if child != nil {
						queue = append(queue, child)
					}
				}
			}
		}
		res = append(res, cur)
	}

	return res
}
```
{% endtab %}
{% endtabs %}

