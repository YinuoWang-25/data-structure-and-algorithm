# 314. Binary Tree Vertical Order Traversal

### Description

Given a binary tree, return the vertical order traversal of its nodes' values. \(ie, from top to bottom, column by column\).

If two nodes are in the same row and column, the order should be from **left to right**.

### Examples

**Examples 1:**

```text
Input: [3,9,20,null,null,15,7]

   3
  /\\
 /  \\
 9  20
    /\\
   /  \\
  15   7 

Output:

[
  [9],
  [3,15],
  [20],
  [7]
]

```

**Examples 2:**

```text
Input: [3,9,8,4,0,1,7]

     3
    /\\
   /  \\
   9   8
  /\\  /\\
 /  \\/  \\
 4  01   7 

Output:

[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]

```

**Examples 3:**

```text
Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5)

     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2

Output:

[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]
```

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
public List<List<Integer>> verticalOrder(TreeNode root) {
    
    List<List<Integer>> res = new ArrayList<>();
    
    if (root == null) {
        return res;
    }
    
    Map<Integer, List<Integer>> map = new TreeMap<>();
    
    Queue<TreeNode> nodeQueue = new LinkedList<>();
    Queue<Integer> colQueue = new LinkedList<>();
    
    nodeQueue.add(root);
    colQueue.add(0);
    
    while (!nodeQueue.isEmpty()) {
        TreeNode curNode = nodeQueue.poll();
        int curCol = colQueue.poll();
        map.putIfAbsent(curCol, new ArrayList<>());
        map.get(curCol).add(curNode.val);
        
        if (curNode.left != null) {
            nodeQueue.offer(curNode.left);
            colQueue.offer(curCol - 1);
        }
        
        if (curNode.right != null) {
            nodeQueue.offer(curNode.right);
            colQueue.offer(curCol + 1);
        }
    }
    
    for (Integer key: map.keySet()) {
        res.add(map.get(key));
    }
    return res;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func verticalOrder(root *TreeNode) [][]int {
	var res [][]int

	if root == nil {
		return res
	}

	var queue []*TreeNode
	var colQueue []int
	hash := make(map[int][]int)

	queue = append(queue, root)
	colQueue = append(colQueue, 0)

	min, max := 0, 0

	for len(queue) != 0 {
		curTreeNode := queue[0]
		curCol := colQueue[0]
		queue = queue[1:]
		colQueue = colQueue[1:]

		min = int(math.Min(float64(min), float64(curCol)))
		max = int(math.Max(float64(max), float64(curCol)))
		if _, ok := hash[curCol]; !ok {
			hash[curCol] = []int{}
		}
		hash[curCol] = append(hash[curCol], curTreeNode.Val)

		if curTreeNode.Left != nil {
			queue = append(queue, (*TreeNode)(curTreeNode.Left))
			colQueue = append(colQueue, curCol - 1)
		}
		if curTreeNode.Right != nil {
			queue = append(queue, (*TreeNode)(curTreeNode.Right))
			colQueue = append(colQueue, curCol + 1)
		}
	}
	for i := min; i<= max; i++ {
		res = append(res, hash[i])
	}
	return res
}
```
{% endtab %}
{% endtabs %}

### GoLang points

1. When create map, we'd better use `make([keyType])[valueType]` rather than just declare it. Or we could not add entry.
2. There are two ways to convert data type. For interface{}, we need to use `.(dataType)`, otherwise, we can use dataType\(otherType\)

