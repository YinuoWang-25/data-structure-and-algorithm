# 113. Path Sum II

### Description

Given the `root` of a binary tree and an integer `targetSum`, return all **root-to-leaf** paths where each path's sum equals `targetSum`.

A **leaf** is a node with no children.

### Examples

**Example 1**

\*\*\*\*![](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

```text
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: [[5,4,11,2],[5,8,4,5]]
```

**Example 2**

\*\*\*\*![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```text
Input: root = [1,2,3], targetSum = 5
Output: []
```

**Example 3**

```text
Input: root = [1,2], targetSum = 0
Output: []
```

### **Constraints**

* The number of nodes in the tree is in the range `[0, 5000]`.
* `-1000 <= Node.val <= 1000`
* `-1000 <= targetSum <= 1000`

### **Solutions**

{% tabs %}
{% tab title="Java" %}
```java
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> res = new ArrayList<>();
    
    if (root == null) {
        return res; 
    }
    
    traverse(res, new ArrayList<>(), root, targetSum);
    
    return res;
}
    
private void traverse(List<List<Integer>> res, List<Integer> cur, TreeNode root, int targetSum) {
    if (root == null) {
        return;
    }
    
    targetSum -= root.val;
    cur.add(root.val);
    
    if (root.left == null && root.right == null) {
        if (targetSum == 0) {
            res.add(new ArrayList<>(cur));
        }
    }
    
    traverse(res, cur, root.left, targetSum);
    traverse(res, cur, root.right, targetSum);
    
    cur.remove(cur.size() - 1);
}
```
{% endtab %}
{% endtabs %}

