# 112. Path Sum

### Description

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.

A **leaf** is a node with no children.

### Examples

#### **Example 1**

\*\*\*\*![](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```text
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
```

#### **Example 2**

\*\*\*\*![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```text
Input: root = [1,2,3], targetSum = 5
Output: false
```

#### **Example 3**

```text
Input: root = [1,2], targetSum = 0
Output: false
```

### **Constraints**

* The number of nodes in the tree is in the range `[0, 5000]`.
* `-1000 <= Node.val <= 1000`
* `-1000 <= targetSum <= 1000`

### **Solutions**

{% tabs %}
{% tab title="Java" %}
```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }
    boolean[] hasPath = new boolean[1];
    
    traverse(hasPath, root, targetSum);
    
    return hasPath[0];
}

private void traverse(boolean[] hasPath, TreeNode root, int curSum) {
    if (root == null) {
        return;
    }
    
    curSum -= root.val;
    
    if (root.left == null && root.right == null) {
        if (curSum == 0) {
            hasPath[0] = true;
        }
    }
    
    traverse(hasPath, root.left, curSum);
    traverse(hasPath, root.right, curSum);
}
```
{% endtab %}
{% endtabs %}

