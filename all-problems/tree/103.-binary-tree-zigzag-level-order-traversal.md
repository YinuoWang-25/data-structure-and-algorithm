# 103. Binary Tree Zigzag Level Order Traversal

### Description

Given a binary tree, return the zigzag level order traversal of its nodes' values. \(ie, from left to right, then right to left for the next level and alternate between\).

For example:Given binary tree `[3,9,20,null,null,15,7]`,

```text
    3
   / \
  9  20
    /  \
   15   7 
  /  \
 6   31
```

return its zigzag level order traversal as:

```text
[
  [3],
  [20,9],
  [15,7],
  [31, 6]
]
```

### Intuition

We use a logical `Deque` and leverage its trait: we can insert and remove on both head and tail of it

For `odd` level, we get elements from `Head` side. For every node we get, we need to insert left child and then right child at `Tail` side.

For `even` level,  we get elements from `Tail` side. For every node we get, we need to insert right child and then left child at `Head` side.

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
	public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
	  List<List<Integer>> res = new ArrayList<>();
	  if (root == null) return res;
	
	  Deque<TreeNode> deque = new LinkedList<>();
	  deque.addFirst(root);
	
	  boolean leftToRight = true;
	
	  while (!deque.isEmpty()) {
	      int size = deque.size();
	      List<Integer> curList = new ArrayList<>();
	
	      for (int i = 0; i < size; i++) {
	          if (leftToRight) {
	              TreeNode cur = deque.pollLast();
	
	              if (cur.left != null) {
	                  deque.addFirst(cur.left);
	              }
	
	              if (cur.right != null) {
	                  deque.addFirst(cur.right);
	              }
	
	              curList.add(cur.val);
	          } else {
	              TreeNode cur = deque.pollFirst();
	
	              if (cur.right != null) {
	                  deque.addLast(cur.right);
	              }
	
	              if (cur.left != null) {
	                  deque.addLast(cur.left);
	              }
	
	              curList.add(cur.val);
	          }
	
	      }
	
	      leftToRight = !leftToRight;
	
	      res.add(curList);
	  }
	
	  return res;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func zigzagLevelOrder(root *TreeNode) [][]int {
	var res [][]int
	if root == nil {
		return res
	}
	deque := []*TreeNode{root}
	level := 0
	for len(deque) > 0 {
		size := len(deque)
		curLevel := make([]int, 0, 0)
		if level%2 == 0 {
			for i := size - 1; i >= 0; i-- {
				curNode := deque[len(deque)-1]
				curLevel = append(curLevel, curNode.Val)
				deque = deque[:len(deque)-1]
				if curNode.Left != nil {
					deque = append([]*TreeNode{curNode.Left}, deque...)
				}
				if curNode.Right != nil {
					deque = append([]*TreeNode{curNode.Right}, deque...)
				}
			}
		} else {
			for i := 0; i < size; i++ {
				curNode := deque[0]
				curLevel = append(curLevel, curNode.Val)
				deque = deque[1:]
				if curNode.Right != nil {
					deque = append(deque, curNode.Right)
				}
				if curNode.Left != nil {
					deque = append(deque, curNode.Left)
				}
			}
		}
		res = append(res, curLevel)
		level = level + 1
	}

	return res
}

```
{% endtab %}
{% endtabs %}

