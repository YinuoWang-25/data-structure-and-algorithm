# 226. Invert Binary Tree

### Description

Invert a binary tree.

### **Example**

Input:

```text
     4
   /   \\
  2     7
 / \\   / \\
1   3 6   9
```

Output:

```text
     4
   /   \\
  7     2
 / \\   / \\
9   6 3   1
```

### Solutions

For iterative solution, the basic idea is to invert node layer by layer

{% tabs %}
{% tab title="Java - recursive" %}
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    
    TreeNode l = invertTree(root.left);
    TreeNode r = invertTree(root.right);
    
    root.left = r;
    root.right = l;
    
    return root;
}
```
{% endtab %}

{% tab title="Java - Iterative" %}
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    
    Deque<TreeNode> q = new LinkedList<>();
    q.offer(root);
    
    while (!q.isEmpty()) {
        TreeNode cur = q.poll();
        TreeNode left = cur.left;
        TreeNode right = cur.right;
        cur.left = right;
        cur.right = left;
        
        if (left != null) q.offer(left);
        if (right != null) q.offer(right);
    }
    return root;
}
```
{% endtab %}

{% tab title="GoLang - Recursive" %}
```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    left := invertTree(root.Right)
    right := invertTree(root.Left)
    root.Left = left
    root.Right = right
    return root
}
```
{% endtab %}

{% tab title="GoLang - Iterative" %}
```go
func invertTree(root *TreeNode) *TreeNode {
	if root == nil {
		return nil
	}
	var queue []*TreeNode
	queue = append(queue, root)

	for len(queue) > 0 {
		cur := queue[0]
		queue = queue[1:]
		left := cur.Left
		right := cur.Right
		cur.Left = right
		cur.Right = left
		if left != nil {
			queue = append(queue, left)
		}
		if right != nil {
			queue = append(queue, right)
		}
	}
	return root
}
```
{% endtab %}
{% endtabs %}



